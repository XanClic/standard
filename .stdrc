$tabstop = 8

hi error bold, termbg: 1

hi tabbar underline
hi tab_active_inner bold
hi tab_active_outer bold
hi tab_inactive_inner underline
hi tab_inactive_outer underline

hi linenr bold
hi statusbar bold

hi placeholder_empty termfg: 4
hi placeholder_line termfg: 3

def backspace_pressed
    if Buffer.active.x > 0
        i [LEFT, DEL]
    elsif Buffer.active.y > 0
        Buffer.active.y -= 1
        Buffer.active.x = Buffer.active.lines[Buffer.active.y].length
        Buffer.active.delete(1)
    end
end

nmap BS => LEFT
imap BS => :backspace_pressed


def delete_rest_of_line
    Buffer.active.delete(Buffer.active.lines[Buffer.active.y].length - Buffer.active.x)
end

def delete_line
    Buffer.active.x = 0
    Buffer.active.delete(Buffer.active.lines[Buffer.active.y].length + 1)
end

def delete_word
    line = Buffer.active.lines[Buffer.active.y]
    word_len = 0

    x = Buffer.active.x
    while line[x] && line[x].word?
        x += 1
        word_len += 1
    end

    word_len += 1 if line[x] && (line[x].space? || (word_len == 0))

    Buffer.active.delete(word_len)
end

nmap X => DEL
nmap 'd$' => :delete_rest_of_line
nmap 'dd' => :delete_line
nmap 'dw' => :delete_word


nmap H => LEFT
nmap L => RIGHT
nmap J => DOWN
nmap K => UP


nmap O   => [I, KEND, "\n".bytes].flatten
nmap O.s => [I, HOME, "\n".bytes, UP].flatten
nmap A.s => [KEND, A]
nmap S   => [DEL, I]
nmap C.s => 'd$a'
nmap 'c$' => 'd$a'
nmap 'cw' => 'dwi'


nmap J.s => [KEND, A, 32, DEL, 27]


nmap T.c     => ":tabnew\n"
nmap W.c     => ":q\n"
nmap LEFT.c  => ":tabprevious\n"
nmap RIGHT.c => ":tabnext\n"


def to_top
    Buffer.active.x = 0
    Buffer.active.y = 0

    reposition_cursor(true)
    ensure_cursor_visibility
end

def to_bottom
    Buffer.active.x = 0
    Buffer.active.y = Buffer.active.lines.length - 1

    reposition_cursor(true)
    ensure_cursor_visibility
end

nmap 'gg' => :to_top
nmap G.s  => :to_bottom

map HOME.c => :to_top
map KEND.c => :to_bottom


def page_down
    # FIXME: This scrolls too far if there are overly long lines
    scroll(BUFFER_HEIGHT)
end

def page_up
    # FIXME: Same applies here
    scroll(-BUFFER_HEIGHT)
end

map PAGEDOWN => :page_down
map PAGEUP   => :page_up


def wheel_up(x, y)
    scroll(-3)
end

def wheel_down(x, y)
    scroll(3)
end

mbdmap MBUTTON_WHEEL_UP   => :wheel_up
mbdmap MBUTTON_WHEEL_DOWN => :wheel_down

def mouse_set_cursor(x, y)
    if y == 0
        buf = Buffer.from_tabs_screen_x(x)
        buf.activate if buf
    elsif y < 1 + BUFFER_HEIGHT
        pos = get_active_buffer_pos_from_screen(x, y)
        Buffer.active.x = pos[0]
        Buffer.active.y = pos[1]

        reposition_cursor(true)
    end
end

mbdmap MBUTTON_LEFT => :mouse_set_cursor
